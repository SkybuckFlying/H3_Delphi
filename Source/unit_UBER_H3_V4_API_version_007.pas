unit unit_UBER_H3_V4_API_version_007;
{ This unit is automatically generated by Chet:
  https://github.com/neslib/Chet }
  
{

UBER H3 V4 API

version 0.07 created on 29 august 2022 by Skybuck Flying 

Note from Skybuck Flying who used CHET to convert the C headers to Pascal:

This unit is a smaller conversion of the UBER H3 VERSION 4 API.

For the full API conversion see the following file:

unit_UBER_H3_V4_API_ALL_version_007.pas

}

{$MINENUMSIZE 4}

interface

const
{$IF Defined(WIN64)}
	UBER_H3_V4 = 'h3_v4.dll';
	_PU = '';
{$ELSE}
{$MESSAGE Error 'Unsupported platform'}
{$ENDIF}

const
	{ TODO : Unable to convert function-like macro: }
	(* H3_EXPORT ( name ) name *)
	H3_NULL = 0;
	H3_VERSION_MAJOR = 4;
	H3_VERSION_MINOR = 0;
	H3_VERSION_PATCH = 0;
	MAX_CELL_BNDRY_VERTS = 10;

type
	// Forward declarations
	PInt64 = ^Int64;
	PLatLng = ^LatLng;
	PCellBoundary = ^CellBoundary;
	PGeoLoop = ^GeoLoop;
	PGeoPolygon = ^GeoPolygon;
	PGeoMultiPolygon = ^GeoMultiPolygon;
	PLinkedLatLng = ^LinkedLatLng;
	PLinkedGeoLoop = ^LinkedGeoLoop;
	PLinkedGeoPolygon = ^LinkedGeoPolygon;
	PCoordIJ = ^CoordIJ;

	(* * @brief Identifier for an object (cell, edge, etc) in the H3 system.
	  *
	  * The H3Index fits within a 64-bit unsigned integer.
	*)
	H3Index = UInt64;
	PH3Index = ^H3Index;
	(* * @brief Result code (success or specific error) from an H3 operation *)
	H3Error = UInt32;

	H3ErrorCodes = (E_SUCCESS = 0, E_FAILED = 1, E_DOMAIN = 2, E_LATLNG_DOMAIN = 3, E_RES_DOMAIN = 4, E_CELL_INVALID = 5, E_DIR_EDGE_INVALID = 6, E_UNDIR_EDGE_INVALID = 7, E_VERTEX_INVALID = 8, E_PENTAGON = 9, E_DUPLICATE_INPUT = 10, E_NOT_NEIGHBORS = 11, E_RES_MISMATCH = 12, E_MEMORY_ALLOC = 13, E_MEMORY_BOUNDS = 14, E_OPTION_INVALID = 15);
	PH3ErrorCodes = ^H3ErrorCodes;

	(* * @struct LatLng
	  @brief latitude/longitude in radians
	*)
	LatLng = record
		/// latitude in radians
		lat: Double;
		/// longitude in radians
		lng: Double;
	end;

	(* * @struct CellBoundary
	  @brief cell boundary in latitude/longitude
	*)
	CellBoundary = record
		/// number of vertices
		numVerts: Integer;
		/// vertices in ccw order
		verts: array [0 .. 9] of LatLng;
	end;

	(* * @struct GeoLoop
	  *  @brief similar to CellBoundary, but requires more alloc work
	*)
	GeoLoop = record
		numVerts: Integer;
		verts: PLatLng;
	end;

	(* * @struct GeoPolygon
	  *  @brief Simplified core of GeoJSON Polygon coordinates definition
	*)
	GeoPolygon = record
		/// exterior boundary of the polygon
		GeoLoop: GeoLoop;
		/// number of elements in the array pointed to by holes
		numHoles: Integer;
		/// interior boundaries (holes) in the polygon
		holes: PGeoLoop;
	end;

	(* * @struct GeoMultiPolygon
	  *  @brief Simplified core of GeoJSON MultiPolygon coordinates definition
	*)
	GeoMultiPolygon = record
		numPolygons: Integer;
		polygons: PGeoPolygon;
	end;

	LinkedLatLng = record
		vertex: LatLng;
		next: PLinkedLatLng;
	end;

	LinkedGeoLoop = record
		first: PLinkedLatLng;
		last: PLinkedLatLng;
		next: PLinkedGeoLoop;
	end;

	LinkedGeoPolygon = record
		first: PLinkedGeoLoop;
		last: PLinkedGeoLoop;
		next: PLinkedGeoPolygon;
	end;

	(* * @struct CoordIJ
	  * @brief IJ hexagon coordinates
	  *
	  * Each axis is spaced 120 degrees apart.
	*)
	CoordIJ = record
		/// i component
		i: Integer;
		/// j component
		j: Integer;
	end;

function latLngToCell(const g: PLatLng; res: Integer; &out: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'latLngToCell';
function cellToLatLng(h3: H3Index; g: PLatLng): H3Error; cdecl; external UBER_H3_V4 name _PU + 'cellToLatLng';
function cellToBoundary(h3: H3Index; gp: PCellBoundary): H3Error; cdecl; external UBER_H3_V4 name _PU + 'cellToBoundary';
function maxGridDiskSize(k: Integer; &out: PInt64): H3Error; cdecl; external UBER_H3_V4 name _PU + 'maxGridDiskSize';
function gridDiskUnsafe(origin: H3Index; k: Integer; &out: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'gridDiskUnsafe';
function gridDiskDistancesUnsafe(origin: H3Index; k: Integer; &out: PH3Index; distances: PInteger): H3Error; cdecl; external UBER_H3_V4 name _PU + 'gridDiskDistancesUnsafe';
function gridDiskDistancesSafe(origin: H3Index; k: Integer; &out: PH3Index; distances: PInteger): H3Error; cdecl; external UBER_H3_V4 name _PU + 'gridDiskDistancesSafe';
function gridDisksUnsafe(h3Set: PH3Index; length: Integer; k: Integer; &out: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'gridDisksUnsafe';
function gridDisk(origin: H3Index; k: Integer; &out: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'gridDisk';
function gridDiskDistances(origin: H3Index; k: Integer; &out: PH3Index; distances: PInteger): H3Error; cdecl; external UBER_H3_V4 name _PU + 'gridDiskDistances';
function gridRingUnsafe(origin: H3Index; k: Integer; &out: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'gridRingUnsafe';
function maxPolygonToCellsSize(const GeoPolygon: PGeoPolygon; res: Integer; flags: UInt32; &out: PInt64): H3Error; cdecl; external UBER_H3_V4 name _PU + 'maxPolygonToCellsSize';
function polygonToCells(const GeoPolygon: PGeoPolygon; res: Integer; flags: UInt32; &out: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'polygonToCells';
function cellsToLinkedMultiPolygon(const h3Set: PH3Index; const numHexes: Integer; &out: PLinkedGeoPolygon): H3Error; cdecl; external UBER_H3_V4 name _PU + 'cellsToLinkedMultiPolygon';
procedure destroyLinkedMultiPolygon(polygon: PLinkedGeoPolygon); cdecl; external UBER_H3_V4 name _PU + 'destroyLinkedMultiPolygon';
function degsToRads(degrees: Double): Double; cdecl; external UBER_H3_V4 name _PU + 'degsToRads';
function radsToDegs(radians: Double): Double; cdecl; external UBER_H3_V4 name _PU + 'radsToDegs';
function greatCircleDistanceRads(const a: PLatLng; const b: PLatLng): Double; cdecl; external UBER_H3_V4 name _PU + 'greatCircleDistanceRads';
function greatCircleDistanceKm(const a: PLatLng; const b: PLatLng): Double; cdecl; external UBER_H3_V4 name _PU + 'greatCircleDistanceKm';
function greatCircleDistanceM(const a: PLatLng; const b: PLatLng): Double; cdecl; external UBER_H3_V4 name _PU + 'greatCircleDistanceM';
function getHexagonAreaAvgKm2(res: Integer; &out: PDouble): H3Error; cdecl; external UBER_H3_V4 name _PU + 'getHexagonAreaAvgKm2';
function getHexagonAreaAvgM2(res: Integer; &out: PDouble): H3Error; cdecl; external UBER_H3_V4 name _PU + 'getHexagonAreaAvgM2';
function cellAreaRads2(h: H3Index; &out: PDouble): H3Error; cdecl; external UBER_H3_V4 name _PU + 'cellAreaRads2';
function cellAreaKm2(h: H3Index; &out: PDouble): H3Error; cdecl; external UBER_H3_V4 name _PU + 'cellAreaKm2';
function cellAreaM2(h: H3Index; &out: PDouble): H3Error; cdecl; external UBER_H3_V4 name _PU + 'cellAreaM2';
function getHexagonEdgeLengthAvgKm(res: Integer; &out: PDouble): H3Error; cdecl; external UBER_H3_V4 name _PU + 'getHexagonEdgeLengthAvgKm';
function getHexagonEdgeLengthAvgM(res: Integer; &out: PDouble): H3Error; cdecl; external UBER_H3_V4 name _PU + 'getHexagonEdgeLengthAvgM';
function edgeLengthRads(edge: H3Index; length: PDouble): H3Error; cdecl; external UBER_H3_V4 name _PU + 'edgeLengthRads';
function edgeLengthKm(edge: H3Index; length: PDouble): H3Error; cdecl; external UBER_H3_V4 name _PU + 'edgeLengthKm';
function edgeLengthM(edge: H3Index; length: PDouble): H3Error; cdecl; external UBER_H3_V4 name _PU + 'edgeLengthM';
function getNumCells(res: Integer; &out: PInt64): H3Error; cdecl; external UBER_H3_V4 name _PU + 'getNumCells';
function res0CellCount(): Integer; cdecl; external UBER_H3_V4 name _PU + 'res0CellCount';
function getRes0Cells(&out: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'getRes0Cells';
function pentagonCount(): Integer; cdecl; external UBER_H3_V4 name _PU + 'pentagonCount';
function getPentagons(res: Integer; &out: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'getPentagons';
function getResolution(h: H3Index): Integer; cdecl; external UBER_H3_V4 name _PU + 'getResolution';
function getBaseCellNumber(h: H3Index): Integer; cdecl; external UBER_H3_V4 name _PU + 'getBaseCellNumber';
function stringToH3(const str: PUTF8Char; &out: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'stringToH3';
function h3ToString(h: H3Index; str: PUTF8Char; sz: NativeUInt): H3Error; cdecl; external UBER_H3_V4 name _PU + 'h3ToString';
function isValidCell(h: H3Index): Integer; cdecl; external UBER_H3_V4 name _PU + 'isValidCell';
function cellToParent(h: H3Index; parentRes: Integer; parent: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'cellToParent';
function cellToChildrenSize(h: H3Index; childRes: Integer; &out: PInt64): H3Error; cdecl; external UBER_H3_V4 name _PU + 'cellToChildrenSize';
function cellToChildren(h: H3Index; childRes: Integer; children: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'cellToChildren';
function cellToCenterChild(h: H3Index; childRes: Integer; child: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'cellToCenterChild';
function compactCells(const h3Set: PH3Index; compactedSet: PH3Index; const numHexes: Int64): H3Error; cdecl; external UBER_H3_V4 name _PU + 'compactCells';
function uncompactCellsSize(const compactedSet: PH3Index; const numCompacted: Int64; const res: Integer; &out: PInt64): H3Error; cdecl; external UBER_H3_V4 name _PU + 'uncompactCellsSize';
function uncompactCells(const compactedSet: PH3Index; const numCompacted: Int64; outSet: PH3Index; const numOut: Int64; const res: Integer): H3Error; cdecl; external UBER_H3_V4 name _PU + 'uncompactCells';
function isResClassIII(h: H3Index): Integer; cdecl; external UBER_H3_V4 name _PU + 'isResClassIII';
function isPentagon(h: H3Index): Integer; cdecl; external UBER_H3_V4 name _PU + 'isPentagon';
function maxFaceCount(h3: H3Index; &out: PInteger): H3Error; cdecl; external UBER_H3_V4 name _PU + 'maxFaceCount';
function getIcosahedronFaces(h3: H3Index; &out: PInteger): H3Error; cdecl; external UBER_H3_V4 name _PU + 'getIcosahedronFaces';
function areNeighborCells(origin: H3Index; destination: H3Index; &out: PInteger): H3Error; cdecl; external UBER_H3_V4 name _PU + 'areNeighborCells';
function cellsToDirectedEdge(origin: H3Index; destination: H3Index; &out: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'cellsToDirectedEdge';
function isValidDirectedEdge(edge: H3Index): Integer; cdecl; external UBER_H3_V4 name _PU + 'isValidDirectedEdge';
function getDirectedEdgeOrigin(edge: H3Index; &out: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'getDirectedEdgeOrigin';
function getDirectedEdgeDestination(edge: H3Index; &out: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'getDirectedEdgeDestination';
function directedEdgeToCells(edge: H3Index; originDestination: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'directedEdgeToCells';
function originToDirectedEdges(origin: H3Index; edges: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'originToDirectedEdges';
function directedEdgeToBoundary(edge: H3Index; gb: PCellBoundary): H3Error; cdecl; external UBER_H3_V4 name _PU + 'directedEdgeToBoundary';
function cellToVertex(origin: H3Index; vertexNum: Integer; &out: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'cellToVertex';
function cellToVertexes(origin: H3Index; vertexes: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'cellToVertexes';
function vertexToLatLng(vertex: H3Index; point: PLatLng): H3Error; cdecl; external UBER_H3_V4 name _PU + 'vertexToLatLng';
function isValidVertex(vertex: H3Index): Integer; cdecl; external UBER_H3_V4 name _PU + 'isValidVertex';
function gridDistance(origin: H3Index; h3: H3Index; distance: PInt64): H3Error; cdecl; external UBER_H3_V4 name _PU + 'gridDistance';
function gridPathCellsSize(start: H3Index; &end: H3Index; size: PInt64): H3Error; cdecl; external UBER_H3_V4 name _PU + 'gridPathCellsSize';
function gridPathCells(start: H3Index; &end: H3Index; &out: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'gridPathCells';
function cellToLocalIj(origin: H3Index; h3: H3Index; mode: UInt32; &out: PCoordIJ): H3Error; cdecl; external UBER_H3_V4 name _PU + 'cellToLocalIj';
function localIjToCell(origin: H3Index; const ij: PCoordIJ; mode: UInt32; &out: PH3Index): H3Error; cdecl; external UBER_H3_V4 name _PU + 'localIjToCell';

implementation

end.
